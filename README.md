# LeetCode-CookBook-Python


## Goal
More than a bunch of problem solutions,
the cookbook aims at helping you become an expert at Data structures and Algorithms.
At the end,
you have not only solved a lot of problems,
but also had a crystal understanding of them.
That is, solving a problem becomes a daily action of you.

Therefore,
LeetCode problems are no more individual problems,
but a repository of problems with connections of similarity and variance.
You should not solve the problem one by one staring from problem #1.
Instead, you have to spend extra time on 
making connections between the problems,
categorizing problems into different groups,
and designing a common working strategy for each group.

Although it will be slower at the beginning,
but it will be much faster at the end with gaining you additional higher level abilities.
There will be strategies and tips available for managing your time wisely through the journey.


## Map
Sub-folders in groups "Analysis-Solutions", "Algorithms" and "Data-structures" are "nodes".
It helps you to organize your knowledge.
With time passing, you should have a virtual map for those nodes and connections in your brain.
That is, LeetCode problems are no more a linearly ordered sequence,
but a graph of nodes with connections.


## Schedule 
One month on "Easy-Medium" questions:
They are the start point of the journey for expanding your power.
They are the individual building blocks for future.
You do not have to go through all of them, 
because many of them are not worth spending the same amount of efforts (See [Tips](#tips)).
They provide you the chance for understanding and getting familiar with concepts and properties,
as well as designing and practising your strategy (See 0026 for example).

Then one "Medium-Hard" problem per day:
They are essential parts of LeetCode, 
because real interview questions are your real targets.
They are more complexed problems composed of lower level problems with new restrictions,
which require you to use your building blocks flexibly.


## Time Management
Only spend less than 20-30 minutes for generating a solution without implementation.
See "How to come up with own solutions".

On one hand, 
it trains you to get used to the real interview scene.

On the other hand, 
remember your goal is to get the problem-solving ability throught the training.
Your time is valuable, you have to spend your time wisely.
You do not have to beat every question during the training. 
The failure guides you by showing what knowledge do you need to make up, 
and what skills do you need to spend your time for.
See "How to check with other solutions".


## How to come up with own solutions
(See 0026 for example)
* Grab a piece of white paper.
* 90-10 stratege: 90% time for thinking, 10% time for coding.
* Read the description carefully.
* Find and write down input-output-functionality.
* Find and write down restrictions.
* Connect to tricks commonly used for this topic and write down.
* Sketch conceptuality of the problem using above steps and run it.
* Decompose using modulization.
* Pseudocode.


## How to implement your own solutions
- #### Never start before coming up with own solutions.
- #### Open a notebook to write it down. 
- #### Review with considering the margin cases.
- #### Draw test cases and manipulate on.
- #### Optimize your codes by combining conditions to share codes, but sometimes it won't be worthy because it reduces readibility.


## After implementation
- #### Copy it to LeetCode and submit.
- #### Record bugs and do analysis (See 0026 for example).
- #### Check other solutions for improvements.


## How to check with other solutions
- #### Use "Debugger" to understand the solution step by step
- #### Abstract the trick to extend your trick set for this topic
- #### Mark the problem number down and redo it with "How to come up with own solutions" in the near future


## Tips
- #### Use filters. E.g., pick "Top 100 Liked Questions".
- #### Do not work on the problems with :-1: >> :+1:. 
- #### Only view discussion with :+1: >> :-1:.
- #### Do not chase conciseness, they might not reduce time complexity (estimate and mind-compile), but sacrifices the readability. (See 0026 for example)
- #### You will be skilled at coding finally, but focus on solving with correctness and time-space complexity at the beginning.
- #### Do not RUSH! The faster is the slower; The slower is the faster.
- #### Mind-compile the code to optimize. 
- #### Optimization and conciseness are different.
- #### Keep in mind the operations can be arranged in different orders and places, trade off by readibility and conciseness.
- #### Instead of hacking on solving problems, it benefits by reviewing sloved problems as well as different solutions. 

## Content Table
| # | Title | Difficulty | Topics | Related | :+1: :-1: | Solutions | Lists |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 0026 | Remove Duplicates from Sorted Array    | Easy   | Array, Two Pointers | 27, 217     | << | Yes |Top Interview Questions |
| 0027 | Remove Element                         | Easy   | Array, Two Pointers | 26          | << |     |                        |
| 0080 | Remove Duplicates from Sorted Array II | Medium | Array, Two Pointers | 26          | << | Yes |                        |
| 0217 | Contains Duplicate                     | Easy   | Array, Hash Table   | 26          | >> |     |Top Interview Questions |
| 0283 | Move Zeroes                            | Easy   | Array, Two Pointers | 27          | >> |     |Top Interview Questions |

